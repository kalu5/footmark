# 前端性能优化全面解析

1. 打开速度怎么变快（首屏优化）
2. 再次打开速度怎么变快（缓存优化）
3. 操作怎么才能顺滑（渲染优化）
4. 动画怎么保证流畅（长任务拆分）

## 你之前项目中都做过哪些性能优化相关的工作

### 首屏加载优化

先说明应用的问题
怎么衡量加载情况好了多少（错误回答： 页面从5s - 3s）

首屏加载指标细化：

1. FP(First paint): 首次绘制，网页首次呈现任何视觉元素的时间
2. FCP(First contentful paint): 首次内容绘制，从网页开始加载到任何内容被绘制到屏幕上的时间
   FP到FCP之间的时间差就是白屏时间
   白屏时间过长，会影响用户体验
3. FMP(First meaningful paint): 首次有效绘制，页面主要内容首次呈现的时间(MutationObserver)
4. LCP(Largest contentful paint): 最大内容绘制，网页中最大的内容元素被绘制到屏幕上的时间

5. INP(Interaction to next paint): 交互到下一次绘制的时间
6. TTI(Time to interactive): 可交互时间，网页中所有内容都被加载并可以与用户交互的时间
7. TBT(Total blocking time): 总阻塞时间，从FCP 到 TTI之间的总和
8. CLS(Cumulative Layout Shift): 累计布局偏移，页面中所有内容的布局偏移的总和(重排)
9. TTFB(Time to first byte): 从开始加载到收到第一个字节的时间

#### 优化方案

主要是解决绘制时间问题，尽量减少资源体积（懒加载、按需导入）

1. 优化图片，Webp, 图片压缩，图片尺寸（在合适的容器内用合适的尺寸图片 1 2 3倍）
2. 字体瘦身（fontmin）,设计型产品，字体子集化（用了哪些字，就最后只生成对应的字体文件）
3. 赖加载资源，图片懒加载，js异步加载
4. css、js文件压缩，打包构建阶段完成（terser）
  - 代码压缩
  - 文件合并
  - 文件拆分
  - Tree Shaking
  - 动态加载
5. Gzip压缩, Btotli
6. SSR, SSG

### 动画卡顿

为什么会卡顿，**JS是单线程**，js执行时间过长，会阻塞页面渲染，导致页面卡顿

#### 优化方案

1. 减少主线程阻塞
   - 优化js执行，较长任务（复杂计算使用web worker, 将任务切分（react Scheduler））
2. GPU
   - 触发GPU的css属性（transform、opacity等）
   - 避免会引起重排问题（复杂的交互不要用position left ,使用transform）
3. requestAnimationFrame
4. 节流防抖

### 应用实战

#### 应用状态管理优化

##### React状态管理
1. 减少全局状态的依赖
   - 将状态尽可能局部化，避免使用全局状态（Redux/Context）管理所有数据
   - 示例：对于某些组件状态，可以使用组件的useState、useReducer等钩子来管理组件状态
2. 优化Context的性能
   - Context的更新会重新渲染有订阅的组件
   - 解决方案：拆分Context, 将不同的逻辑存储在多个Context中，降低重新渲染范围
3. 使用高效的状态管理库
   - Zustand、Jotai
4. 避免不必要的状态更新

##### Vue状态管理

1. 精简Vuex、Pinia的全局状态
   - 将不需要全局共享的状态迁移到组件内，减少全局状态更新的开销
   - reactive
2. 模块化和按需加载
   - 将vuex或pinia的状态模块化，按需加载，提高性能
3. 避免多余的getter计算
   - 将计算逻辑放在组件的computed/watch中，而不是store的getter中


#### 应用视图层更新优化

##### React视图层优化

1. 使用React.memo防止不必要的重新渲染
   - 对函数组件进行包裹，只有prop变化才重新渲染
   ``` jsx
   const Component = React.memo(({data}) => {
    return <div>{data}</data>
   })
   ```
2. useMemo和useCallback的优化
   - 使用useMemo缓存复杂的计算结果，使用useCallback缓存函数实例
   ``` jsx
   const computedValue = useMemo(() => computed(data), [data])
   const handleClick = useCallback(() => doSomething(), [])
   ```
3. 拆分组件
   - 将页面拆分为更小的组件，只更新必要的部分，避免整体重新渲染
4. 使用虚拟滚动
   - 对于长列表的渲染，使用虚拟滚动技术（React-Virtualized/React-Window）,只渲染可视区域的内容
5. 适当使用批处理更新
   - 确保多个状态可以批量处理，减少渲染次数

##### Vue视图层优化

1. 避免多余的响应式数据
   - 只对需要响应式的数据使用reactive或ref，静态数据不需要响应式
2. 使用v-once和v-memo
   - 对于不需要更新的静态内容，可以使用v-once渲染一次
3. 拆分组件和局部更新
   - 将大组件拆分为多个子组件，使用keep-alive缓存不活跃的组件，减少重新渲染的开销
4. 避免使用watch过度
   - 优化watch的逻辑，仅对必要的依赖进行监听，减少副作用执行
5. 使用虚拟滚动优化长列表
   - vue-virtual-scroller

#### 事件和渲染细节优化

1. 节流和防抖（滚动、输入）
2. 事件绑定
   - vue中使用.native修饰符直接绑定dom事件
   - react中，避免在子组件上过多传递回调函数
3. 避免不必要的dom操作
   - 减少直接操作dom的次数，尽量通过框架的响应式机制处理更新
4. 异步加载懒加载
   - 路由、图片懒加载降低首次渲染压力
5. 使用请求合并
   - 多个请求合并，减少多余的网络开销

## 具体的性能指标体系和评估策略

（主导/推进/负责）分析性能问题，给出性能问题的解决方案，实施，建立完整的指标体系持续监控，持续优化

### 性能指标体系建立

见首屏加载指标细化 ↑↑↑

常见的指标，使用 Performance、PerformanceObserver 和 webvital来做计算


其他指标
- DNS查询时间
- 资源加载时间
- 长任务时间，主线程占用时长超过50ms

### 性能采集指标

1. 常规指标采集： Performance、PerformanceObserver
2. 自定义指标采集： FMP 通过MutationObserver 监听 DOM 变化来自定义计算
3. 额外的指标：首字节、服务端上报

上报的方式：xhr（可能会跨域），图片上报

### 性能评估

监控指标和数据都有了，然后计算、统计、评估得到性能报告，具体分析性能，持续解决

实践中的性能优化

- 减少资源体积：压缩css/js, 使用tree shaking 和代码分割
- 懒加载和预加载：延迟加载非关键资源，优先加载关键css和js
- 服务端渲染（SSR）：提升首屏渲染速度
- 长列表优化：实现虚拟滚动


## 如何落地应用优化这部分工作，团队代码质量和整体管理落实

全栈平台，性能监控全链路设计

### 指标体系设计、计算、评估等

原则:
- 清晰并且可量化：指标必须直观易于理解，例如LCP/CLS/INP等
- 与业务目标挂钩：例如关键页面的加载时间（LCP）直接影响用户留存率
- 覆盖加载、交互、稳定性；确保监控全面，不遗漏关键用户体验
- 埋点，为了追踪用户浏览痕迹，以此来评判产品用户体验

1. 加载性能
   - FP：首次绘制
   - FCP：首次内容绘制
   - LCP：最大内容绘制
   - TTFB: 首字节时间
2. 交互性能
   - INP：交互到下一次绘制的时间
   - TBT：总阻塞时间
3. 稳定性
   - CLS：累计布局偏移
4. 业务自定义指标
   - 页面中某些功能模块加载时间
   - 特定的用户行为路径完成时间

### 设计的路径

1. 指标设计
2. 采集
3. 上报
4. 数据清洗
5. 数据统计分析
6. 可视化


### 性能评估策略

#### 基础测试
1. 确定目标设备和网络环境
   - 使用ChromeDevTools网络调节
2. 基准值定义
   - 根据行业标准和历史数据定义性能基准（LCP < 2.5秒， CLS < 0.1）


